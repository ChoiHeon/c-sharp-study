# GC (Garbage Collector)

* C와 C++에서는 직접 메모리를 할당 및 해제하는 방식으로 관리하지만, JAVA나 C# 등의 언어는 메모리를 관리해주는 GC가 존재합니다.
* 즉, 메모리의 할당과 해제가 GC에 의해서 이루어집니다.

<br>

## 메모리 할당

* 힙(Heap) 영역에 메모리를 할당합니다. C와 C++과의 차이점은 GC가 할당이 가능한 주소의 첫 부분을 가리키므로, 별도로 공간을 탐색할 필요가 없다는 점입니다.
* 따라서 메모리 할당이 발생하면 GC에서 가리키는 주소를 참고해서, 할당이 가능할 경우 메모리를 할당 및 할당 가능 주소를 이동시킵니다.

<br>

## 메모리 해제

* GC는 힙 영역에 메모리가 쌓이다보면 특정 시점에 더 이상 사용되지 않는 메모리를 해제합니다. 
* 이 때 발생한 빈 공간을 사용중인 공간들로 채운 뒤, 할당 가능 주소를 변경합니다.

<br>

## 가비지 수집

* GC가 메모리를 조사한 뒤, 해제할 메모리를 선택 및 해제하는 시점입니다.

<br>

* .Net(닷넷)의 GC는 메모리를 총 3 세대로 관리합니다.
  * 0 세대 - 처음 할당되는 객체는 0세대로 지정됩니다. 0세대의 메모리가 일정 크기 이상이 되면 가비지 수집이 발생합니다. 
  * 1 세대 - 가비지 수집 시 해제되지 않은 0 세대는 1 세대로 승격됩니다. 1 세대의 메모리가 일정 크기 이상이 되면 가비지 수집이 발생합니다.
  * 2 세대 - 가비지 수집 시 해제되지 않은 1 세대는 2 세대로 승격됩니다. 2 세대의 메모리가 일정 크기 이상이 되면 가비지 수집이 발생합니다. 이 때 해제되지 않은 메모리는 그대로 2 세대를 유지합니다.
  * GC가 발생할 떄는 모든 스레드 작업이 중단됩니다. 해제된 메모리를 사용중인 객체의 메모리로 채워야 하기 때문입니다.

<br>

* GC는 0 세대에 대해 가비지 수집을 자주 수행합니다. 때문에 대부분의 가비지 수집은 0 세대에 대해서만 이루어집니다. 

  * 이는 최근에 생성한 객체일수록 생명 주기가 짧을 확률이 높기 때문입니다.

<br>

* GC에서 수행하는 가비지 수집의 종류는 다음과 같습니다.

  * GC 0 - 0 세대에 대해서 가비지 수집을 진행합니다.
  * GC 1 - 0~1 세대에 대해 가비지 수집을 진행합니다.
  * GC 2 - 0~2 세대에 대해 가비지 수집을 진행합니다.

* 위에서 아래로 갈수록 큰 오버헤드가 발생합니다.

<br>

* 다음 함수를 통해서 임의로 가비지 수집을 발생시킬 수 있습니다.

	> GC.Collect()
	
* 하지만 잦은 GC.Collect는 성능 저하를 야기할 수 있습니다.

  * 모든 세대에 대해서 가비지 수집이 실행되고, 가비지 수집에 의해 해제되지 않은 객체들은 세대가 승격됩니다.
  * 이 때, 자주 발생하는 GC 0에 의해서 해제되지 않는 메모리가 다수 발생하기 때문에 성능 저하를 야기할 수 있습니다.

<br>

## 할당할 크기에 따른 메모리 할당 방식

* C#의 CLR(Common Language Runtime)에서 할당할 객체의 크기에 따라서 크게 두 개의 힙으로 나눠서 관리합니다.
  * SOH (Small Object Heap) - 용량이 작은 객체 (85KB 미만)을 저장
  * LOH (Large Object Heap) - 용량이 큰 객체(85KB 이상)을 저장

<br>

**[차이점]**

| SOH                                                          | LOH                                                          |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 메모리 해제시, 빈 공간이 없도록 기존의 메모리를 재배치합니다. | 메모리 해제시, 빈 공간을 그대로 둡니다.<br />공간을 채우기 위한 재배치시의 오버헤드가 크기 때문입니다. |
| 0~2세대로 나누어서 관리합니다.                               | 가비지 수집시 2 세대로 취급됩니다.<br />0 세대로 지정하면 GC 0이 너무 자주 발생하기 때문입니다. |

* 따라서 용량이 큰 객체를 자주 할당하거나 해제하면 LOH의 파편화로 인해 할당에 실패할 수 있습니다.

* 또는 큰 오버헤드가 발생하는 GC 2가 자주 발생하므로 성능 저하를 야기할 수 있습니다.

  

  

